# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# ç¯å¢ƒå˜é‡
require 'dotenv'
Dotenv.load
# ENV['FASTLANE_PASSWORD'] = "123456"
# puts ENV['FASTLANE_PASSWORD']


# ------------------------------------------------------------------------------

default_platform(:ios)

platform :ios do

  # å¼‚å¸¸æ•è·
  before_all do
    UI.message("Fastlane started")
  end
  
  after_all do |lane|
    UI.success("Fastlane completed successfully for lane: #{lane}")
  end
  
  error do |lane, exception|
    UI.error("Error in lane: #{lane}")
    UI.error("Message: #{exception.message}")
    UI.error("Backtrace: #{exception.backtrace.join("\n")}")
  
    # è®°å½•é”™è¯¯æ—¥å¿—
    File.open("fastlane_error.log", "a") do |file|
      file.puts("[#{Time.now}] Error in lane: #{lane}")
      file.puts("Message: #{exception.message}")
      file.puts("Backtrace: #{exception.backtrace.join("\n")}")
      file.puts("----")
    end
  
    # å‘é€é£ä¹¦é€šçŸ¥
    send_feishu_message(
      title: "#{SCHEME_NAME} æ‰“åŒ…å¤±è´¥",
      message: "Lane: #{lane}, \nError: #{exception.message}"
    )
  end

  # æ¸…ç†æ—§æ–‡ä»¶
  lane :cleanup do
    UI.message("ğŸ§¹ Cleaning up old files...")
    sh "rm -rf ~/Desktop/#{SCHEME_NAME}-IPA"
    sh "rm -rf moji_log.txt"
    sh "rm -rf #{SCHEME_NAME}/moji_log.txt"
    sh "rm -rf #{SCHEME_NAME}/PPAutoPackageScript/moji_log.txt"
    sh "touch moji_log.txt"
    UI.success("âœ… Cleanup completed.")
  end

  # è§£é”é’¥åŒ™ä¸²
  lane :my_unlock_keychain do
    UI.message("ğŸ”“ Unlocking keychain...")
    unlock_keychain(
      path: "~/Library/Keychains/login.keychain-db",
      password: "hugecore0726"
    )
    # sh "security unlock-keychain -p hugecore0726"
    UI.success("âœ… Keychain unlocked.")
  end

  # è·å–Gitå˜æ›´è®°å½•
  lane :git_log_changes do
    UI.message("ğŸ”“ Git Log Changes...")

    # sh 'git log $(git rev-parse HEAD~1)..$(git rev-parse HEAD)'

    log_changes = changelog_from_git_commits(
      # between: ["7b092b3", "HEAD"],  # Optional, lets you specify a revision/tag range between which to collect commit info
      commits_count: 5,
      pretty: "- (%ae) %s",# Optional, lets you provide a custom format to apply to each commit when generating the changelog text
      date_format: "short",# Optional, lets you provide an additional date format to dates within the pretty-formatted string
      match_lightweight_tag: false,  # Optional, lets you ignore lightweight (non-annotated) tags when searching for the last tag
      merge_commit_filtering: "exclude_merges" # Optional, lets you filter out merge commits
    )

    send_feishu_message(title: "#{SCHEME_NAME} å˜æ›´è®°å½•", message: log_changes)

    UI.success("âœ… Git Log Changes.")
  end

  # å®‰è£…ä¾èµ–
  lane :install_pods do
    UI.message("ğŸ“¦ Installing Cocoapods dependencies...")
    cocoapods(
      repo_update: true,
      clean_install: true,
      podfile: "./Podfile"
    )
    UI.success("âœ… Pods installed.")
  end

  # æ£€æŸ¥å…³é”®å­—
  lane :check_keywords do
    check_keyword = "r_todo"
    UI.message("ğŸ” Scanning for keyword: #{check_keyword}...")
    
    # è·å–æ‰€æœ‰ .m å’Œ .swift æ–‡ä»¶
    files = Dir["../**/*.{m,swift}"]
    offending_files = []

    # UI.message("ğŸ” files: #{files}")

    # éå†æ–‡ä»¶æŸ¥æ‰¾å…³é”®å­—
    files.each do |file|
      if File.read(file).include?(check_keyword)
        offending_files << file
        UI.error("âŒ Keyword found in: #{file}")
      end
    end

    # å¦‚æœæœ‰è¿è§„æ–‡ä»¶åˆ™ç»ˆæ­¢ä»»åŠ¡
    if offending_files.any?
      UI.user_error!("Production environment contains TODOs in the following files:\n#{offending_files.join("\n")}")
    else
      UI.success("âœ… No TODOs found in production environment.")
    end
  end

  # è‡ªåŠ¨æ‰“åŒ…
  lane :build do
    UI.message("ğŸ“¦ Building the app...")
    gym(
      scheme: "#{SCHEME_NAME}",
      workspace: "#{SCHEME_NAME}.xcworkspace",
      configuration: "#{CONFIGURATION}",
      clean: true,
      export_method: "#{EXPORT_METHOD}", # æ ¹æ®éœ€æ±‚é€‰æ‹© app-store / ad-hoc / enterprise
      output_directory: "~/Desktop/#{SCHEME_NAME}-IPA",
      output_name: "#{SCHEME_NAME}.ipa",
      xcargs: "-allowProvisioningUpdates"
    )
    UI.success("âœ… Build completed.")
  end

  # ä¸Šä¼  IPA å’Œ plist
  lane :upload_ipa do
    ipa_path = "~/Desktop/#{SCHEME_NAME}-IPA/#{SCHEME_NAME}.ipa"
    plist_path = "../../manifest/manifest.plist"
    sh "cat #{plist_path}"
    version = get_version_number(xcodeproj: "#{SCHEME_NAME}.xcodeproj", target: "#{SCHEME_NAME}")

    # æ›´æ–° plist æ–‡ä»¶
    UI.message("ğŸ“ Updating plist file...")
    ipa_url = "#{IPA_URL_SUFFIX}/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.ipa"
    plist_data = Plist.parse_xml(plist_path)
    plist_data['items'][0]['assets'][0]['url'] = ipa_url
    plist_data['items'][0]['metadata']['bundle-version'] = version
    File.write(plist_path, plist_data.to_plist)
    UI.success("âœ… Plist file updated.")

    # ä¸Šä¼  IPA å’Œ plist åˆ°æœåŠ¡å™¨
    UI.message("ğŸš€ Uploading IPA and plist to server...")

    # æ‹·è´å‰å…ˆåˆ›å»ºè·¯å¾„
    sh "ssh -p 2023 admin@192.168.1.3 -f 'mkdir -p #{IPA_RELPATH_SUFFIX}/manifest'"
    sh "scp -P 2023 #{ipa_path} admin@192.168.1.3:#{IPA_RELPATH_SUFFIX}/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.ipa"
    sh "scp -P 2023 #{plist_path} admin@192.168.1.3:#{IPA_RELPATH_SUFFIX}/manifest/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.plist"

    UI.success("âœ… IPA and plist uploaded.")
    UI.important("Install with Safari: itms-services://?action=download-manifest&url=#{IPA_URL_SUFFIX}/manifest/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.plist")
  end

  # å¤‡ä»½ archive æ–‡ä»¶
  # lane :backup_archive do
  #   UI.message("ğŸ“¦ Backing up the archive file...")

  #   archive_path = "../archive/#{SCHEME_NAME}-IPA/#{SCHEME_NAME}.xcarchive"
  #   zip_path = "../archive/#{SCHEME_NAME}-IPA/#{SCHEME_NAME}.app.dSYM.zip"

  #   version = get_version_number(xcodeproj: "#{SCHEME_NAME}.xcodeproj", target: "#{SCHEME_NAME}")
  #   build_number = get_build_number(xcodeproj: "#{SCHEME_NAME}.xcodeproj")

  #   # å‹ç¼© archive æ–‡ä»¶å¤¹
  #   sh "cd ../archive/#{SCHEME_NAME}-IPA && zip -r #{SCHEME_NAME}.app.dSYM.zip #{SCHEME_NAME}.xcarchive/dSYMs/#{SCHEME_NAME}.app.dSYM"

  #   # ä¸Šä¼  zip æ–‡ä»¶åˆ°æœåŠ¡å™¨
  #   UI.message("ğŸš€ Uploading archive zip to server...")

  #   # æ‹·è´å‰å…ˆåˆ›å»ºè·¯å¾„
  #   sh "ssh -p 2023 admin@192.168.1.3 -f 'mkdir -p #{IPA_RELPATH_SUFFIX}/archive'"
  #   sh "scp -P 2023 #{zip_path} admin@192.168.1.3:#{IPA_RELPATH_SUFFIX}/archive/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.zip"

  #   send_feishu_message(
  #     title: "#{SCHEME_NAME} å½’æ¡£å¤‡ä»½æˆåŠŸ",
  #     message: "ç‰ˆæœ¬å·: #{version}, \nBuildç‰ˆæœ¬å·: #{build_number}, \nä¸‹è½½åœ°å€ï¼š#{IPA_URL_SUFFIX}/archive/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.zip"
  #   )

  #   UI.success("âœ… Archive zip uploaded.")
  #   UI.important("Download archive zip: #{IPA_URL_SUFFIX}/archive/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.zip")
  # end

  # ç”Ÿæˆä¸‹è½½é“¾æ¥
  lane :generate_download_link do
    UI.message("ğŸŒ æ—¶é—´æˆ³:#{TIMESTAMP}")
    
    version = get_version_number(xcodeproj: "#{SCHEME_NAME}.xcodeproj", target: "#{SCHEME_NAME}")
    download_url = "#{IPA_URL_SUFFIX}/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.ipa"
    manifest_url = "itms-services://?action=download-manifest&url=#{IPA_URL_SUFFIX}/manifest/#{SCHEME_NAME}_#{version}_#{TIMESTAMP}.plist"

    UI.message("ğŸŒ Download link generated:")
    UI.important(download_url)

    send_feishu_message_ipa(
      title: "#{SCHEME_NAME} #{CONFIGURATION}åŒ…",
      branch: "#{COMMIT_BRANCH}",
      download_text: "ææµ‹åŒ…ä¸‹è½½",
      download_link: download_url,
      manifest_text: "Safariå®‰è£…(å¤åˆ¶å®Œæ•´åœ°å€åˆ°Safariæ‰“å¼€)",
      manifest_link: manifest_url
    )
  end

  # ä¸Šä¼ TF
  lane :upload_ipa_to_testflight do
    UI.message("ğŸš€ å¼€å§‹ä¸Šä¼ TFåŒ…...")

    # å­˜å‚¨åˆ°å†…å­˜ä¸­å¯é€šè¿‡ä¸Šä¸‹æ–‡è¯»å–ï¼šlane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    app_store_connect_api_key(
      key_id: "Q2LWSVJK3N",
      issuer_id: "743641a2-b6b4-4169-8b12-6887be28d044",
      key_filepath: "../CICD/AppStoreConnectAPI-GitAuto-AuthKey_Q2LWSVJK3N.p8"
    )

    # apikey = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
    # UI.message("apikeyä¸ºï¼š\n #{apikey[:issuer_id]}")
    
    ipa_path = "~/Desktop/#{SCHEME_NAME}-IPA/#{SCHEME_NAME}.ipa"
    upload_to_testflight(
      ipa: ipa_path,
      skip_waiting_for_build_processing: true, # è·³è¿‡ç­‰å¾…æ„å»ºè¿‡ç¨‹
      skip_submission: true # åªä¸Šä¼ ä¸æäº¤å®¡æ ¸
    )

    # æˆåŠŸå‘é€é£ä¹¦é€šçŸ¥
    version = get_version_number(xcodeproj: "#{SCHEME_NAME}.xcodeproj", target: "#{SCHEME_NAME}")
    build_number = get_build_number(xcodeproj: "#{SCHEME_NAME}.xcodeproj")

    send_feishu_message(
      title: "#{SCHEME_NAME} TFä¸Šä¼ æˆåŠŸ",
      message: "ç‰ˆæœ¬å·: #{version}, \nBuildç‰ˆæœ¬å·: #{build_number}"
    )

    UI.success("âœ… ä¸Šä¼ TFæˆåŠŸ")
  end


  # å‘é€é£ä¹¦æ‰“åŒ…é€šçŸ¥
  # å‘½ä»¤è¡Œæµ‹è¯•
  # fastlane send_feishu_message_ipa title:"KoriDict æµ‹è¯•åŒ…" branch:"dev" download_text:"æµ‹è¯•åŒ…ä¸‹è½½" download_link:"#{download_url}" manifest_text:"Safariåœ°å€" manifest_link:"#{download_url}"
  lane :send_feishu_message_ipa do |options|
    require 'json'
    require 'net/http'
    require 'uri'

    # è·å–å‚æ•°
    title = options[:title] || "#{SCHEME_NAME} ææµ‹åŒ…"
    branch = options[:branch] || "dev"
    download_text = options[:download_text] || "#{SCHEME_NAME}"
    download_link = options[:download_link] || "http://www.example.com/"
    manifest_text = options[:manifest_text] || "Safariåœ°å€"
    manifest_link = options[:manifest_link] || "http://www.example.com/"

    # ç»„ç»‡æ¶ˆæ¯å†…å®¹
    message_content = {
      "msg_type" => "post",
      "content" => {
        "post" => {
          "zh_cn" => {
            "title" => title,
            "content" => [
              [
                { "tag" => "text", "text" => "æ‰“åŒ…åˆ†æ”¯ï¼š#{branch}" },
                { "tag" => "text", "text" => "\nä¸‹è½½åœ°å€: " },
                { "tag" => "a", "text" => download_text, "href" => download_link },
                { "tag" => "text", "text" => "\n#{manifest_text}: \n#{manifest_link}" }
                # { "tag" => "a", "text" => manifest_text, "href" => manifest_link }
              ]
            ]
          }
        }
      }
    }.to_json

    # ä½¿ç”¨ curl å‘½ä»¤å‘é€è¯·æ±‚(å¦‚æœdataåŒ…å«å•å¼•å·ä¼šå¯¼è‡´å‘ç”Ÿè¯·æ±‚å¤±è´¥)

    # sh "curl --location '#{FEISHU_WEBHOOK}' " \
    #   "--header 'Content-Type: application/json' " \
    #   "--data '#{message_content}'"

    uri = URI.parse(FEISHU_WEBHOOK)
    request = Net::HTTP::Post.new(uri)
    request.content_type = "application/json"
    request.body = message_content

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == "https") do |http|
      http.request(request)
    end

  end

  # å‘é€é£ä¹¦é€šç”¨é€šçŸ¥
  # fastlane send_feishu_message title:"KoriDict æµ‹è¯•åŒ…" message:"-"
  lane :send_feishu_message do |options|
    require 'json'
    require 'net/http'
    require 'uri'

    # è·å–å‚æ•°
    title = options[:title] || "#{SCHEME_NAME} æ‰“åŒ…æç¤º"
    message = options[:message] || " "

    # ç»„ç»‡æ¶ˆæ¯å†…å®¹
    message_content = {
      "msg_type" => "post",
      "content" => {
        "post" => {
          "zh_cn" => {
            "title" => title,
            "content" => [
              [
                { "tag" => "text", "text" => message }
              ]
            ]
          }
        }
      }
    }.to_json

    # ä½¿ç”¨ curl å‘½ä»¤å‘é€è¯·æ±‚

    # sh "curl --location '#{FEISHU_WEBHOOK}' " \
    #   "--header 'Content-Type: application/json' " \
    #   "--data '#{message_content}'"

    # å‘é€é£ä¹¦é€šçŸ¥
    uri = URI.parse(FEISHU_WEBHOOK)
    request = Net::HTTP::Post.new(uri)
    request.content_type = "application/json"
    request.body = message_content

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == "https") do |http|
      http.request(request)
    end

  end

  # æ‰“æµ‹è¯•åŒ…
  lane :build_debug do
    # æµç¨‹å¼€å§‹
    # check_keywords
    my_unlock_keychain
    cleanup
    install_pods
    build
    upload_ipa
    generate_download_link
    git_log_changes
  end

  # æ‰“ç”Ÿäº§åŒ…
  lane :build_release do
    build_debug
  end

  # æ‰“å‘å¸ƒä¸Šæ¶åŒ…
  lane :build_appstore do |options|
    # æµç¨‹å¼€å§‹
    check_keywords
    my_unlock_keychain
    cleanup

    # è‡ªåŠ¨å¢åŠ ç‰ˆæœ¬å·
    build_version = options[:build_version]
    UI.message("ğŸ“¦ buildç‰ˆæœ¬å·è‡ªå¢ï¼š#{build_version}")
    
    increment_build_number({
      build_number: build_version
    })

    install_pods
    build
    # upload_ipa
    # generate_download_link
    upload_ipa_to_testflight
    git_log_changes
    # backup_archive
  end

  # æ•´ä½“æµç¨‹
  lane :build_and_deploy do |options|
    UI.message("ğŸ“¦ Building the build_and_deploy...")

    # debug, release, appstore
    type_build = options[:type_build] || "appstore"
    
    # è®¾ç½®å…¨å±€å˜é‡

    SCHEME_NAME = "KoriDict"
    # IPAåŒ…ä¸‹è½½åœ°å€å‰ç¼€
    IPA_URL_SUFFIX = "https://gzoffice.mojidict.com:9000/iOS/koridict"
    # IPAåŒ…ç‰©ç†åœ°å€
    IPA_RELPATH_SUFFIX = "/home/admin/file-server-static/iOS/koridict"
    # æ—¶é—´æˆ³æå–ï¼šå‘½åIPAåŒ…éœ€è¦
    TIMESTAMP = Time.now.strftime("%Y-%m-%d-%H-%M-%S")

    # é£ä¹¦ Webhook URL
    # ios æ‰“åŒ…ç¾¤
    FEISHU_WEBHOOK = "https://open.feishu.cn/open-apis/bot/v2/hook/b578e28c-fde5-42bd-8ef5-9621f435094b"
    # è°ƒè¯•æ‰“åŒ…ç¾¤
    # FEISHU_WEBHOOK = "https://open.feishu.cn/open-apis/bot/v2/hook/ccf6db93-3020-4ba6-aa35-ca407aea4fc3"
 
    CONFIGURATION = "Debug" # Debug, Release
    EXPORT_METHOD = "development" # app-store, ad-hoc, development
    COMMIT_BRANCH = 'dev'

    # è¯»å–ä¼ å…¥çš„å‚æ•° `type_build`
    type_build = options[:type_build]

    UI.message("å¼€å§‹æ‰“åŒ…, æ„å»ºç±»å‹: #{type_build}")

    # æ ¹æ® `type_build` å‚æ•°å€¼æ‰§è¡Œä¸åŒé€»è¾‘
    case type_build
    when "debug"
      UI.message("æ‰§è¡Œ Debug æ„å»ºé€»è¾‘")

      CONFIGURATION = "Debug" 
      EXPORT_METHOD = "development"
      COMMIT_BRANCH = 'dev'

      build_debug
    when "release"
      UI.message("æ‰§è¡Œ Release æ„å»ºé€»è¾‘")

      CONFIGURATION = "Release"
      EXPORT_METHOD = "ad-hoc"
      COMMIT_BRANCH = 'master'

      build_release
    when "appstore"
      UI.message("æ‰§è¡Œ App Store æ„å»ºé€»è¾‘")

      CONFIGURATION = "Release"
      EXPORT_METHOD = "app-store"
      COMMIT_BRANCH = 'master'

      build_date = options[:build_date]
      unless build_date&.match(/^\d{8}$/)
        UI.user_error!("âŒ buildç‰ˆæœ¬å·æ ¼å¼é”™è¯¯ï¼Œæ­£ç¡®æ ¼å¼ä¸º8ä½å¹´æœˆæ—¥æ•°å­—ï¼Œå¦‚ï¼š20241226")
      end
      # ä¸Šä¼ åˆ° TestFlight æˆ– App Store
      build_appstore(build_version: build_date)
    else
      UI.error("æœªè¯†åˆ«çš„æ„å»ºç±»å‹: #{type_build}")
      UI.user_error!("è¯·æä¾›æœ‰æ•ˆçš„ type_build å‚æ•°: debug, release, appstore")
    end

    UI.message("CONFIGURATIONï¼š#{CONFIGURATION} EXPORT_METHODï¼š#{EXPORT_METHOD}")

    # sh("some_command_that_might_fail") # æ¨¡æ‹Ÿå‡ºé”™çš„å‘½ä»¤

    UI.success("ğŸ‰ Build and deployment completed: #{type_build}")
  end

  lane :test do
    UI.message("æ‰§è¡Œæµ‹è¯•é€»è¾‘")
  end

end



# æµ‹è¯•é£ä¹¦é€šçŸ¥

# curl --location 'https://open.feishu.cn/open-apis/bot/v2/hook/ccf6db93-3020-4ba6-aa35-ca407aea4fc3' \
# --header 'Content-Type: application/json' \
# --data '{
#     "msg_type": "post",
#     "content": {
#         "post": {
#             "zh_cn": {
#                 "title": "KoriDictææµ‹åŒ…",
#                 "content": [
#                     [
#                         {
#                             "tag": "text",
#                             "text": "æ‰“åŒ…åˆ†æ”¯ï¼šdev"
#                         },
#                         {
#                             "tag": "text",
#                             "text": "\nä¸‹è½½åœ°å€: \nhttps://open.feishu.cn/open-apis/bot/v2/hook/ccf6db93-3020-4ba6-aa35-ca407aea4fc3"
#                         }
#                     ]
#                 ]
#             }
#         }
#     }
# }'
